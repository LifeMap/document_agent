# 대화 로그 - 2026-01-12

## 프로젝트 초기 설정

### CLAUDE.md 생성
- 사용자 요청: /init 명령으로 CLAUDE.md 파일 생성
- 결과: 프로젝트 개요, 기술 스택, 아키텍처, 개발 단계 포함하여 생성
- 이후 한국어로 변환 및 프로젝트 규칙 추가

### Git 저장소 연결
- 사용자 요청: git 레포지토리 연결
- 명령: git init && git remote add origin git@github.com:LifeMap/document_agent.git
- 결과: 성공

---

## 학습 시작 - 환경 설정

### venv vs conda 논의
- 사용자 질문: LangChain, LangGraph 설치를 위해 venv vs conda 선택
- 논의 내용:
  - 이 프로젝트는 API 호출 기반 (모델 학습 X)
  - 복잡한 바이너리 빌드 불필요
  - Python 버전 여러 개 관리 불필요
- 결론: venv로 충분

### 가상환경 생성
- 사용자 작업: myenv라는 이름으로 venv 생성 완료
- 확인: bin, include, lib, pyvenv.cfg 폴더 구조 확인됨

### 가상환경 관련 학습
- 활성화: source myenv/bin/activate
- 비활성화: deactivate
- 터미널 세션마다 다시 활성화 필요
- VS Code Python: Select Interpreter로 자동 활성화 설정 가능

### .gitignore 논의
- 질문: myenv를 .gitignore에 추가해야 하는 이유?
- 학습 포인트:
  - venv는 Python 인터프리터 + 패키지 포함 (용량 큼)
  - 플랫폼별 바이너리 포함
  - requirements.txt로 재생성 가능
- Python venv vs Node.js 비교:
  - myenv/lib/site-packages/ ≈ node_modules/
  - myenv/bin/python ≈ 시스템 Node
  - requirements.txt ≈ package.json
- 결과: .gitignore에 myenv/ 추가 완료

---

## 패키지 설치

### 설치 명령
- 가상환경 활성화 후 실행
- pip install langchain langgraph chromadb streamlit

### requirements.txt 생성
- 명령: pip freeze > requirements.txt
- 결과: 117개 패키지 목록 생성

### 직접 의존성 vs 전이 의존성 학습
- 질문: 4개만 설치했는데 왜 117개?
- 학습 포인트:
  - 직접 의존성 (Direct Dependency): 내가 직접 설치한 패키지
  - 전이 의존성 (Transitive Dependency): 패키지가 필요로 하는 다른 패키지
  - pip show langchain의 Requires 항목으로 확인 가능

### pip freeze 장단점
- 장점: 모든 버전 고정 → 동일한 환경 재현
- 단점: 직접 설치한 것 구분 어려움, 업그레이드 시 충돌 가능
- 대안: requirements.txt (직접 의존성) + requirements.lock (전체 고정)

### pipreqsnb 논의
- 사용자 제안: pipreqsnb 사용?
- 논의: pipreqsnb는 코드의 import문을 분석하는 방식
- 결론: 현재 코드가 없어서 사용 불가, 나중에 코드 작성 후 정리용으로 사용 가능

---

## RAG 파이프라인 학습

### RAG 개념 이해
- 문서 로딩 → 청킹 → 임베딩 → Chroma 저장

### 각 단계의 목적
1. 문서 로딩: PDF/txt 등 다양한 형식에서 텍스트 추출
2. 청킹: LLM 컨텍스트 제한, 검색 정확도, 비용 절감
3. 임베딩: 의미(semantic)를 벡터로 표현
4. 벡터DB: 유사도 검색에 최적화

### 청킹 vs 형태소 분리
- 형태소 분리: "나는 밥을 먹었다" → ["나", "는", "밥", "을", "먹었다"]
- 청킹: 10페이지 문서 → 의미 단위의 조각들

---

## VS Code 디버그 설정

### Python 확장 설치
- VS Code에 Microsoft Python 확장 설치 필요
- 설치 후 Developer: Reload Window로 새로고침

### Python 인터프리터 선택
- Cmd + Shift + P → "Python: Select Interpreter" → myenv 선택
- 하단 상태바에서 Python 클릭하면 "Select Language Mode"가 나옴 (이건 다른 기능)

### 디버그 실행
- Cmd + Shift + P → "Debug: Start Debugging"
- 또는 Fn + F5 (맥에서는 F5가 시스템 기능으로 매핑되어 있음)

---

## 문서 로딩 구현

### TextLoader 사용
- langchain_community.document_loaders에서 TextLoader import
- loader.load()는 Document 객체들의 리스트 반환
- 단일 파일이어도 리스트로 반환 (일관된 인터페이스 유지)

### 에러 해결
- ModuleNotFoundError: No module named 'langchain_community'
- 해결: pip install langchain-community (별도 패키지)

### Document 객체 구조
- page_content: 문서 내용
- metadata: 메타데이터

---

## 청킹 구현

### RecursiveCharacterTextSplitter
- chunk_size: 각 청크의 최대 크기
- chunk_overlap: 청크 간 겹치는 부분
- length_function: 길이 계산 함수

### 코드 수정
- 처음: splitter 객체만 생성하고 반환
- 수정: text_splitter.split_documents(data)로 실제 분할 수행

### chunk_overlap 동작 확인
- RecursiveCharacterTextSplitter는 자연스러운 구분점(\n\n, \n 등)에서 우선 분할
- 이력서처럼 줄바꿈이 많은 문서는 깔끔한 경계에서 분할되어 overlap이 보이지 않음
- CharacterTextSplitter(separator='')로 강제 문자 단위 분할하면 overlap 확인 가능

### Splitter 비교
| Splitter | 특징 |
|----------|------|
| RecursiveCharacterTextSplitter | 자연스러운 구분점 우선, overlap 최소화 |
| CharacterTextSplitter(separator='') | 강제 문자 단위 분할, overlap 확실히 적용 |

### 결론
- RecursiveCharacterTextSplitter가 실제 사용 시 더 좋음
- 문장/문단 중간에서 자르지 않으려고 노력함
- overlap은 어쩔 수 없이 중간에서 잘릴 때의 보험

---

## 다음 단계
- 임베딩 → Chroma 저장
